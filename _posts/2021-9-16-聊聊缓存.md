---
layout:     post
title:      "聊聊缓存"
date:       2021-09-16 22:18:00
author:     "Mountain"
header-img: "img/post-bg-2015.jpg"
tags:
    - 前端综合
---

## 前言（背景）
### 问题：前端每次修改代码发布新包后，页面没有显示修改后的内容，需要手动清除本地缓存

## 一、缓存的分类

浏览器缓存主要分为：HTTP缓存+浏览器缓存
[![img](../img/in-post/缓存/01%E7%BC%93%E5%AD%98%E6%80%BB%E8%A7%88.png)]()

## 二、浏览器缓存：

常用到的浏览器缓存：cookie、sessionStorage、localStorage

| 本地缓存       | 容量 | 特征                                                         |
| -------------- | ---- | ------------------------------------------------------------ |
| cookie         | 4KB  | 1、兼容各种浏览器   2、每次都会和后台交互   3、可设置过期时间 |
| sessionStorage | 5MB  | 1、H5新特性，不兼容低版本浏览器   2、本地存储，不会每次和后台交互   3、会话关闭则缓存失效 |
| localStorage   | 5MB  | 1、H5新特性，不兼容低版本浏览器   2、本地存储，不会每次和后台交互   3、本地缓存，除非手动删除，否则会一直存在 |

## 三、HTTP缓存

HTTP缓存： 当客户端向服务器请求资源时，会先抵达浏览器缓存，如果浏览器有“要请求资源”的副本，就可以直接从浏览器缓存中提取而不是从原始服务器中提取这个资源。

常见的HTTP缓存只能缓存GET请求响应的资源，对于其他类型的响应则无能为力

HTTP缓存都是从第二次请求开始的。第一次请求资源时，服务器返回资源，并在respone header头中回传资源的缓存参数；第二次请求时，浏览器判断这些请求参数，命中强缓存就直接200，否则就把请求参数加到request header头中传给服务器，看是否命中协商缓存，命中则返回304，否则服务器会返回新的资源。

浏览器三级缓存的优先级顺序：

- 先查找内存，如果内存中存在，从内存中加载memory cache
- 如果内存中未查找到，选择硬盘获取，如果硬盘中有，从硬盘中加载disk cache
- 如果硬盘中未查找到，那就进行网络请求，加载到的资源缓存到硬盘和内存

### 3.1 强缓存

- 缓存效果
- 缓存状态码
- HTTP相关头部字段
- 缓存机制

#### 3.1.1 缓存效果

在强制缓存生效期间，客户端不会与服务器产生交互，直接从缓存中读取资源，此时页面响应速度快；但如果服务器资源被修改，是无法拿到最新资源的（比如修改样式后有时不生效，强制刷新）

#### 3.1.2  缓存状态码

强制缓存时状态码为200，资源的size为 memory cache 或者 disk cache

- from memory cache：字面理解是从内存中，其实也是字面的含义，这个资源是直接从内存中拿到的，不会请求服务器一般已经加载过该资源且缓存在了内存当中，当关闭该页面时，此资源就被内存释放掉了，再次重新打开相同页面时不会出现from memory cache的情况。
- from disk cache：同上类似，此资源是从磁盘当中取出的，也是在已经在之前的某个时间加载过该资源，不会请求服务器但是此资源不会随着该页面的关闭而释放掉，因为是存在硬盘当中的，下次打开仍会from disk cache
- 资源本身大小数值：当http状态为200是实实在在从浏览器获取的资源，当http状态为304时该数字是与服务端通信报文的大小，并不是该资源本身的大小，该资源是从本地获取的。

| 状态码 | 类型              | 说明                                                         |
| ------ | ----------------- | ------------------------------------------------------------ |
| 200    | from memory cache | 状态码灰色，不请求网络资源，资源在内存中。一般更新频率较高的js脚本、字体、图片会存在内存中。页面关闭时资源会被内存释放 |
| 200    | from disk cache   | 状态码灰色，不请求网络资源，资源在磁盘当中。一般更新频率较低的js、css文件会存在内存当中。页面关闭时资源不会释放 |
| 200    | 资源大小数值      | 资源大小数值，从服务器上下载最新资源直存在                   |
| 304    | 报文大小          | 请求服务器发现资源没有更新，使用本地资源（协商缓存）         |

#### 3.1.3 HTTP相关头部字段

HTTP报文中与强制缓存相关的头部字段：Pragma、Cache-Control、Expires

| 头部字段                  | 可选值                                                       | 优先级                                               | 优缺点                                                       |
| ------------------------- | ------------------------------------------------------------ | ---------------------------------------------------- | ------------------------------------------------------------ |
| Pragma（HTTP/1.0）        | no-cache                                                     | 状态码灰色，不请求网络资源，资源在内存中。被内存释放 | 高                                                           |
| Cache-Control（HTTP/1.1） | no-cache、no-store、max-age、public / private、 must-revalidate | 中                                                   | 1、请求头和响应头中都支持这个属性   2、不适用于HTTP/1.0   3、在缓存未失效前，资源被修改后无法获取到 |
| Expires（HTTP/1.0+）      | GMT时间                                                      | 低                                                   | 1、服务器和客户端的时间不一致会出问题   2、适用于HTTP/1.0和HTTP/1.1   3、在缓存未失效前，获取不到修改后的资源 |

#### 3.1.4 Cache-Control字段的取值

- 请求头中的Cache-Control取值：

  [![img](../img/in-post/缓存/02%E8%AF%B7%E6%B1%82%E4%B8%AD%E7%9A%84cache-control%E5%8F%96%E5%80%BC.png)]()

- 响应中的Cache-Control取值：

  [![img](../img/in-post/缓存/03%E5%93%8D%E5%BA%94%E4%B8%AD%E7%9A%84cache-control%E5%8F%96%E5%80%BC.png)]()

**强缓存demo实践**：请求中的Cache-Control与响应中Cache-Control的区别  

- 客户端和服务器端都不设置缓存策略：默认不会命中缓存
- 服务器端设置cache-control: max-age=30，客户端不设置：命中强缓存，在缓存有效时间内不进行接口请求
- 客户端设置ajax.setRequestHeader('cache-control','max-age=30')，服务器端不设置：没有命中缓存，在该事件内仍然进行接口请求
- 客户端设置ajax.setRequestHeader('cache-control','max-age=30')，服务端设置cache-control: max-age=10：命中缓存，在服务端设置的缓存时间内不进行接口请求，超过该时间后进行接口请求
- 客户端不需要缓存设置ajax.setRequestHeader('cache-control','max-age=0')，服务器端设置cache-control':'max-age=10： 没有命中缓存，每次都进行接口请求
- 结论：
  - 只有服务端才能开启缓存，默认是不会走缓存的
  - 走了强缓存就不会再向服务端发送请求了
  - 客户端的请求头中只有设置了cache-control为：'no-cache' | 'max-age=0'才会生效（也就是客户端不想走强缓存的时候生效），除非后端对这个字段做特殊处理

如果max-age=0出现在请求中，则代表浏览器要求服务器，此次请求必须重新返回最新文件（请求完成后，你会看到http状态码是200）；

如果max-age=0出现在响应中，则代表服务器要求浏览器你在使用本地缓存的时候，必须先和服务器进行一遍通信（协商缓存） 更多关于Cache-Control在请求头和响应头中的区别，可查看 https://stackoverflow.com/questions/1046966/whats-the-difference-between-cache-control-max-age-0-and-no-cache

#### 3.1.5 缓存机制

- 缓存存储策略：HTTP内容是否可以被缓存到本地

  - Cache-Control的 Public、Private、no-cache、max-age 、no-store 都指明响应内容是否可以被客户端存储的。比如设置public后可以将响应数据存储到本地，但此时并不意味着后续浏览器会直接从缓存中读取数据并使用，因为它无法确定本地缓存的数据是否可用（可能已经失效）

- 缓存过期策略：判断客户端是否可以直接从本地缓存中加载数据。

  - Expires：HTTP1.0，绝对时间的GMT格式的时间字符串，代表资源失效时间
  - Cache-Control：HTTP1.1，相对时间max-age，代表资源有效期
  - Expires和Cache-Control同时使用：当Cache-Control值为public、private时，Expires有效；当Cache-Control值为no-store、no-cache、max-age等时，Expires失效
  - 在没有提供任何浏览器缓存过期策略的情况下，浏览器遵循一个启发式缓存过期策略：根据响应头中2个时间字段 Date 和 Last-Modified 之间的时间差值，取其值的10%作为缓存时间周期。

- 缓存数据标记为已过期只是告诉客户端不能再直接从本地读取缓存了，需要再发一次请求到服务器去确认，并不等同于本地缓存数据从此就没用了，有些情况下即使过期了还是会被再次用到

  [![img](../img/in-post/缓存/04%E5%BC%BA%E7%BC%93%E5%AD%98.png)]()

### 3.2 协商缓存

- 缓存效果
- 缓存状态码
- HTTP相关头部字段

#### 3.2.1 缓存效果

协商缓存时本地也有缓存，但不直接使用缓存，而是通过与服务器交互后判断本地缓存是否能使用，因此协商缓存下使用的有可能是本地缓存，也有可能是服务器返回的新资源。第一次请求服务器时，服务器会返回资源，并且返回一个资源的缓存标识，一起存到浏览器的缓存数据库。当第二次请求资源时，浏览器会首先将缓存标识发送给服务器，服务器拿到标识后判断标识是否匹配，如果不匹配，表示资源有更新，服务器会将新数据和新的缓存标识一起返回到浏览器；如果缓存标识匹配，表示资源没有更新，并且返回 304 状态码，浏览器就读取本地缓存服务器中的数据

#### 3.2.2 缓存状态码

当协商缓存判断资源未更新时，状态码为304，即使用缓存的数据。当协商缓存判断资源有更新时，状态码为200，通过服务器接口返回新的资源和缓存信息

#### 3.2.3 HTTP相关头部字段

HTTP报文中与协商缓存相关的头部字段：Etag / If-Not-Match、Last-modified / If-Modified-Since。协商缓存中的请求头和响应头需要同步出现

| 头部字段                                      | 可选值  | 优先级 | 优缺点                                                       |
| --------------------------------------------- | ------- | ------ | ------------------------------------------------------------ |
| Etag / If-Not-Match（HTTP/1.1）               | 校验值  | 高     | 1、默认使用hash算法，在分布式环境下可能会出现不同服务器生成的Etag值不一致    2、精确的判断资源有无被修改，可识别一秒内的修改次数    3、计算Etag需要性能消耗 |
| Last-modified / If-Modified-Since（HTTP/1.0） | GMT时间 | 低     | 1、只要资源修改，无论内容有无变化，都会将资源返回客户端   2、以时刻为标识，无法获取一秒内的修改变化   3、某些服务器不能准确获取最后修改时间   4、服务器和客户端的时间不一致会出问题 |

#### 3.2.4 缓存机制

**Last-Modified**

- 服务端在返回资源时，会将该资源的最后更改时间通过Last-Modified字段返回给客户端。
- 客户端下次请求时通过If-Modified-Since或者If-Unmodified-Since带上Last-Modified
- 服务端检查该时间是否与服务器的最后修改时间一致：
  - 如果一致，则返回304状态码，不返回资源
  - 如果不一致则返回200和修改后的资源，并带上新的时间。

**Etag**

-单纯的以修改时间来判断还是有缺陷，比如文件的最后修改时间变了，但内容没变。对于这样的情况，我们可以使用etag来处理。

- 服务器通过某个算法对资源进行计算，取得一串值(类似于文件的md5值)，之后将该值通过etag返回给客户端
- 客户端下次请求时通过If-None-Match或If-Match带上该值
- 服务器对该值进行对比校验：如果一致则不要返回资源。
  - 如果一致，则返回304状态码，不返回资源
  - 如果不一致则返回200和修改后的资源，并带上新的时间

### 3.3 两种缓存的对比

强缓存和协商缓存的对比情况如下：

[![img](../img/in-post/缓存/05%E4%B8%A4%E7%A7%8D%E7%BC%93%E5%AD%98%E5%AF%B9%E6%AF%94.png)]()

- 对于强制缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行协商缓存策略。
- 对于协商缓存，将缓存信息中的Etag和Last-Modified通过请求发送给服务器，由服务器校验，返回304状态码时，浏览器直接使用缓存。

**缓存demo实践**： 强缓存与协商缓存综合实践 

- Express中默认是启用Last-Modified和Etag，先禁用`lastModified: false, etag: false `：每次都进行接口请求
- 服务端设置`maxAge: 10000, lastModified: false, etag: false`实现强缓存：在10秒内没有接口请求，10秒后重新请求
- 服务端设置`lastModified: true, etag: true`实现协商缓存：首次进行接口请求200，后续接口请求结果是304，修改内容后首次请求结果是200，后续请求结果是304
- 服务端同时设置`maxAge: 10000, lastModified: true, etag: true`实现强缓存和协商缓存：在10秒内没有进行接口请求，10秒后进行接口请求结果是304；修改内容后如果在上一个10秒内则仍然没有接口请求，10秒后进行接口请求200返回新资源

**缓存过程总结**

（1）浏览器第一次发起请求时，本地无缓存，向web服务器发送请求，服务器起端响应请求，浏览器端缓存：

[![img](../img/in-post/缓存/06%E6%B5%8F%E8%A7%88%E5%99%A8%E9%A6%96%E6%AC%A1%E8%AF%B7%E6%B1%82.png)]()

- 浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识
- 浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中

（2）浏览器在第一次请求发生后，再次发送请求：

- 获取资源头部信息的cache-control和Expires判断是否过期，若未过期则读取缓存
- 若过期，浏览器携带之前资源的header发送请求，服务器判断是否真的过期
- 若服务器比对后发现过期，重新返回资源和200状态码
- 若服务器比对后发现未过期，返回304状态码

[![img](../img/in-post/缓存/07%E6%B5%8F%E8%A7%88%E5%99%A8%E7%AC%AC%E4%BA%8C%E6%AC%A1%E8%AF%B7%E6%B1%82.png)]()

更多关于HTTP缓存相关实践可查看 https://www.jianshu.com/p/32733a356acf

## 四、解决方案

#### 为什么要清除缓存？

浏览器识别文件靠的是文件名,所以当一个文件名在浏览器里第一次出现时,他就会根据浏览器的机制被缓存,下次请求同名文件时,就会从缓存中读取

#### 浏览器会对哪些内容进行缓存？

浏览器中默认会对 html css js 等静态文件、以及重定向进行缓存

#### 怎么适当利用缓存

1、修改文件名：比如手动给文件添加一个随机数，从而达到修改文件名的效果。比如http://www.baidu.com/test.js?v=20210101，每次发版时,修改v=xxxx，则浏览器不会读缓存

2、vue在打包时，webpack已经配置好了前端资源缓存机制hash、chunkhash、contenthash，当文件被修改后这些hash会变动，导致发布时的资源名不同，浏览器缓存未被命中，从而更新缓存；但是入口HTML文件会因为缓存造成更新问题，因此要对入口文件设置不使用强缓存（优先级较低）

```
<meta http-equiv="pragram" content="no-cache">
<meta http-equiv="cache-control" content="no-cache, no-store, must-revalidate">
```

3、在nginx转发代理中进行设置：虽然css、js打包后文件名更新了，但把打包好的index.html放到服务器里去的时候，index.html在服务器端可能是有缓存的，这需要在服务器配置不让缓存index.html

```
location ~ .*\.(html)$ {  // 对html文件限制缓存
    add_header Cache-Control no-store;  // 不缓存
    // 或者用add_header Cache-Control no-cache;替代上面那一句，协商缓存
    add_header Pragma no-cache;
}
location ~* \.(woff|css|js)$ {
    proxy_pass http://kubernetes;
    expires 1d; // 静态资源文件设置缓存时间
}
```

4、根据资源的变动频率区分设置：

- 频繁变动的资源【HTML文件】：Cache-Control：no-cache 结合 Etag
- 不常变动的资源【css、js、图片等】：Cache-Control：max-age=31536000 结合 文件名hash或版本号等
