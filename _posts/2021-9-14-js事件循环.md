---
layout:     post
title:      "js事件循环"
date:       2021-09-14 17:18:00
author:     "Mountain"
header-img: "img/post-bg-2015.jpg"
tags:
    - 前端综合
---

## 从一道面试题聊聊事件循环中各任务执行顺序

**关于js事件循环小口诀**： 有同先同，然后再异；有微先微，然后再宏；如此反复，牢记心中。

某大厂面试题：

```
setTimeout(function () {
  console.log("1");
}, 0);
async function async1() {
  console.log("2");
  const data = await async2();
  console.log("3");
  return data;
}
async function async2() {
  return new Promise((resolve) => {
    console.log("4");
    resolve("async2的结果");
  }).then((data) => {
    console.log("5");
    return data;
  });
}
async1().then((data) => {
  console.log("6");
  console.log(data);
});
new Promise(function (resolve) {
  console.log("7");
  resolve() // 这里如果删掉呢？
}).then(function () {
  console.log("8");
});
```

首先setTimeout 扔进宏任务队列，然后执行async1方法，第一个打印出来的就是**2**，然后遇到await，先右后左，执行async2方法(是个Promise)，输出**4**，.then（log5）进微任务，return data。**注意！**由于async2() 返回的是一个promise 结果，**所以会阻塞下面的代码执行**(如果不是promise，则不阻塞后面同步代码，当然await还是会挂起，执行外部的同步队列，执行完再执行await后面的同步队列)，让出执行栈，先执行该作用域外部的同步和微任务。执行promise里的log7，输出**7**，然后.then(log8)进微任务。这时候执行栈同步任务已经执行完了，去异步事件队列里找微任务，这时候先执行.then(log5)，return `async2的结果`，输出**5**，然后输出**8**，外部微任务执行完了。这时候返回await 继续执行，`async2的结果`赋值给data并返回，执行log3，输出**3**，async1() 执行完后.then 进入微任务，这时候主执行栈执行完了，先检查微任务队列，输出**6**，输出**async2的结果**，微任务队列执行完了，执行宏任务，输出**1**，至此所有执行完毕。

所以最终的结果是 2 4 7 5 8 3 6 async2的结果 1

上面的如果promise里面resolve 注释了，就不会打印log8



变形：

```
setTimeout(function () {
  console.log("1");
}, 0);
let result = 999;
async function async1() {
  console.log("2");
  result =  await async2();
  console.log(result);
  console.log("3");
  return result;
}
async function async2() {
  return new Promise((resolve) => {
    console.log("4");
    resolve("async2的结果");
  }).then((data) => {
    console.log("5");
    return data;
  });
}
async1().then((data) => {
  console.log("6");
  console.log(data);
});
new Promise(function (resolve) {
  console.log("7");
  resolve()
}).then(function () {
  console.log("8");
  console.log(result);
});
```

这个结果就可以看的出来 await 是阻塞了以它向左和向下的所有执行，挂起先执行外部同步和微任务队列（但是宏任务不执行），都执行完了再回来继续后面的执行步骤。

