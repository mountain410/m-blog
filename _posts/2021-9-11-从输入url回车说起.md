## 一道经典面试题，说说从浏览器输入一个URL回车后发生了什么

### URL 解析

- 这里我们只考虑输入的是一个URL 结构字符串，如果是非 URL 结构的字符串，则会用浏览器默认的搜索引擎搜索该字符串
- URL 主要由 协议、主机、端口、路径、查询参数、锚点6部分组成。
- 输入URL后，浏览器会解析出协议、主机、端口、路径等信息，并构造一个HTTP请求

### 缓存

1. 浏览器发送请求前，根据请求头的`expires`和`cache-control`判断是否命中（包括是否过期）强缓存策略，如果命中，直接从缓存获取资源，并不会发送请求。如果没有命中，则进入下一步。
2. 没有命中强缓存规则，浏览器会发送请求，根据请求头的`last-modified`和`etag`判断是否命中协商缓存，如果命中，直接从缓存获取资源。如果没有命中，则进入下一步。
3. 如果前两步都没有命中，则直接从服务端获取资源。

#### 强缓存

强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程。强缓存又分为两种`Expires`和`Cache-Control`，用来判断是否过期。

#### 弱缓存（协商缓存）

协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程。主要也是两种：

- Last-Modified(响应头)、If-Modified-Since(请求头)
- ETag(响应头)、If-None-Match(请求头)

### DNS解析

1. 浏览器缓存——浏览器会先检查是否在缓存中，没有则调用系统库函数进行查询
2. 系统缓存——操作系统也有自己的 DNS缓存，但在这之前，会向检查域名是否存在本地的 Hosts 文件里，没有则向 DNS 服务器发送查询请求
3. 路由器缓存——路由器也有自己的缓存
4. ISP DNS 缓存——ISP DNS 就是在客户端电脑上设置的首选 DNS 服务器，它们在大多数情况下都会有缓存
5. 根域名服务器查询——在前面所有步骤没有缓存的情况下，本地 DNS 服务器会将请求转发到互联网上的根域，从根域名服务器一路迭代递归查下去，最终返回目标ip

### TCP/IP连接：三次握手

客服端和服务端在进行http请求和返回的工程中，需要创建一个`TCP connection`（由客户端发起）,`http`不存在连接这个概念，它只有请求和响应。请求和响应都是数据包，它们之间的传输通道就是`TCP connection`。

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/370b0bfa7c8b47c6ad8d2a39f2d40f42~tplv-k3u1fbpfcp-watermark.awebp" alt="img" style="zoom:50%;" />

- SYN(synchronous建立联机)
- ACK(acknowledgement 确认)
- PSH(push传送)
- FIN(finish结束)
- RST(reset重置)
- URG(urgent紧急)

第一次握手：主机A发送位码为`SYN＝1`，随机产生`Seq  number=1234567`的数据包到服务器，主机B由`SYN=1`知道，A要求建立联机；（第一次握手，由浏览器发起，告诉服务器我要发送请求了）

第二次握手：主机B收到请求后要确认联机信息，向A发送`ack number=(主机A的seq+1)`，`SUN=1，ACK=1234567 + 1`，随机产生`Seq=7654321`的包；（第二次握手，由服务器发起，告诉浏览器我准备接受了，你赶紧发送吧）

第三次握手：主机A收到后检查`ack number`是否正确，即第一次发送的`seq number+1`，以及位码`SYN`是否为1，若正确，主机A会再发送`ack number=(主机B的seq+1)`，`ack=7654321 + 1`，主机B收到后确认`Seq`值与`ACK=7654321+ 1`则连接建立成功；（第三次握手，由浏览器发送，告诉服务器，我马上就发了，准备接受吧）

> 总是要问：为什么需要三次握手，两次不行吗？其实这是由TCP的自身特点**可靠传输**决定的。客户端和服务端要进行可靠传输，那么就需要**确认双方的`接收`和`发送`能力**。第一次握手可以确认客服端的`发送能力`,第二次握手，服务端`SYN=1,Seq=Y`就确认了`发送能力`,`ACK=X+1`就确认了`接收能力`,所以第三次握手才可以确认客户端的`接收能力`。不然容易出现丢包的现象。



### HTTP请求





### 服务端处理请求并返回

每台服务器上都会安装处理请求的应用——Web Server。常见的Web Server 产品有 `apache`、`nginx`、`IIS` 或 `Lighttpd` 等。

HTTP请求一般可以分为两类，静态资源 和 动态资源。

请求访问静态资源，这个就直接根据url地址去服务器里找就好了。

请求动态资源的话，就需要web server把不同请求，委托给服务器上处理相应请求的程序进行处理（例如 CGI 脚本，JSP 脚本，servlets，ASP 脚本，服务器端 JavaScript，或者一些其它的服务器端技术等），然后返回后台程序处理产生的结果作为响应，发送到客户端。

服务器在处理请求的时候主要有三种方式：

- 第一种：是用一个线程来处理所有的请求，并且同时只能处理一个请求，但是这样的话性能是非常的低的。
- 第二种：是每一个请求都给他分配一个线程但是当链接和请求比较多的时候就会导致服务器的cpu不堪重负。
- 第三种：就是采用复用I/O的方式来处理例如通过epoll方式监视所有链接当链接状态发生改变的时候才去分配空间进行处理。



### 浏览器渲染页面

<img src="https://higwendolyn.github.io/Alias/images/chorme11.png" alt="渲染过程.png" style="zoom:80%;" />

- 解析html创建dom树
- 解析css构建css树
- 运行JS脚本，等到JS文件下载完成后，通过DOM API 和CSS API 操作DOM Tree和CSS Rule Tree，然后结合Css 树和DOM合并成render树。
- 布局render树（layout/reflow），负责各元素尺寸、位置的计算
- 绘制render树（paint)，绘制页面像素信息
- 浏览器将各层的信息发送给GPU进程，GPU会将各层合成（composite）显示在页面上，渲染完毕后就是load事件了，之后就是自己的JS逻辑处理了

#### 回流和重绘

- 重绘

当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。

- 回流

当Render Tree中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。

**引起回流：**

1. 页面首次渲染
2. 浏览器窗口大小发生改变
3. 元素尺寸或位置发生改变
4. 元素内容变化（文字数量或图片大小等等）
5. 元素字体大小变化
6. 添加或者删除可见的DOM元素
7. 激活CSS伪类（例如：:hover）
8. 查询某些属性或调用某些方法

引起回流的属性和方法：

- clientWidth、clientHeight、clientTop、clientLeft
- offsetWidth、offsetHeight、offsetTop、offsetLeft
- scrollWidth、scrollHeight、scrollTop、scrollLeft
- scrollIntoView()、scrollIntoViewIffNeeded()
- getComputedStyle()
- getBoundingClientRect()
- scrollTo()

**如何减少回流**

- css

1. 避免使用table布局;
2. 尽可能在DOM树的最末端改变class;
3. 避免设置多层内联样式;
4. 将动画效果应用到position属性为absolute或fixed的元素上;
5. 避免使用CSS表达式（例如：calc()）。

- JS

1. 避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。
2. 避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。
3. 也可以先为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。
4. 避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。
5. 对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。



### 浏览器运行js，事件循环

<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/22/16cb90a48d95abb9~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom: 50%;" />

#### **1. 词法分析**

JS 脚本加载完毕后，会首先进入语法分析阶段，它首先会分析代码块的语法是否正确，不正确则抛出“语法错误”，停止执行。

几个步骤：

- 分词，例如将`var a = 2`，，分成`var`、`a`、`=`、`2`这样的词法单元。
- 解析，将词法单元转换成抽象语法树（AST）。
- 代码生成，将抽象语法树转换成机器指令。

#### **2. 预编译**

JS 有三种运行环境：

- 全局环境
- 函数环境
- eval

每进入一个不同的运行环境都会创建一个对应的执行上下文，根据不同的上下文环境，形成一个函数调用栈，栈底永远是全局执行上下文，栈顶则永远是当前执行上下文。

**创建执行上下文**

创建执行上下文的过程中，主要做了以下三件事：

- 创建变量对象
  - 参数、函数、变量
- 建立作用域链
  - 确认当前执行环境是否能访问变量
- 确定 This 指向

#### **3. 执行**

**JS 线程**

虽然 JS 是单线程的，但实际上参与工作的线程一共有四个：

> 其中三个只是协助，只有 JS 引擎线程是真正执行的

- JS 引擎线程：也叫 JS 内核，负责解析执行 JS 脚本程序的主线程，例如 V8 引擎
- 事件触发线程：属于浏览器内核线程，主要用于控制事件，例如鼠标、键盘等，当事件被触发时，就会把事件的处理函数推进事件队列，等待 JS 引擎线程执行
- 定时器触发线程：主要控制`setInterval`和`setTimeout`，用来计时，计时完毕后，则把定时器的处理函数推进事件队列中，等待 JS 引擎线程。
- HTTP 异步请求线程：通过XMLHttpRequest连接后，通过浏览器新开的一个线程，监控readyState状态变更时，如果设置了该状态的回调函数，则将该状态的处理函数推进事件队列中，等待JS引擎线程执行。

**注：浏览器对同一域名的并发连接数是有限的，通常为 6 个。**

**宏任务**

分为：

- 同步任务：按照顺序执行，只有前一个任务完成后，才能执行后一个任务
- 异步任务：不直接执行，只有满足触发条件时，相关的线程将该异步任务推进任务队列中，等待JS引擎主线程上的任务执行完毕时才开始执行，例如异步Ajax、DOM事件，setTimeout等。

**微任务**

微任务是ES6和Node环境下的，主要 API 有：`Promise`，`process.nextTick`。

微任务的执行在宏任务的同步任务之后，在异步任务之前。

#### 4.浏览器的事件环(Event Loop)

JavaScript是一个单进程的语言，同一时间不能处理多个任务，所以何时执行宏任务，何时执行微任务？我们需要有这样的一个判断逻辑存在。

*简单概括为*：执行同步代码 ==> **检查微任务并执行** ==> 执行宏任务1 ==> **检查微任务并执行** ==> 执行宏任务2 ==> **检查微任务并执行** ==> 执行宏任务3 ……

一次 Eventloop 循环会处理一个宏任务和所有这次循环中产生的微任务

![Event Loop.png](https://higwendolyn.github.io/Alias/images/chorme8.png)

每次执行栈中的代码就是一个**宏任务(task)**，而消息队列中的任务会按顺序放到下一次的**宏任务(task)中，每个宏任务(task)在执行时，V8 都会重新创建栈，然后随着宏任务(task)中函数调用，栈也随之变化，最终，当该宏任务(task)执行结束时，整个栈又会被清空，接着主线程继续执行下一个宏任务(task)**。



